using System;
using ETWManifest;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Linq;

class TraceParserGen
{
    public TraceParserGen(Provider provider)
    {
        m_provider = provider;

        // group the events by event Name.   
        m_eventsByName = new SortedDictionary<string, List<Event>>();
        foreach (var evnt in m_provider.Events)
        {
            List<Event> eventsForName = GetEventsForName(evnt.EventName, evnt.Id);
            eventsForName.Add(evnt);
        }
    }

    /// <summary>
    /// Given an eventName, return a list of all events with that name.   Warns if two events
    /// with the same name have different Ids, and retnames the event to be unique.  
    /// </summary>
    /// <param name="eventName"></param>
    /// <param name="eventId"></param>
    /// <returns></returns>
    private List<Event> GetEventsForName(string eventName, ushort eventId)
    {
        List<Event> eventsForName;
        if (!m_eventsByName.TryGetValue(eventName, out eventsForName))
            m_eventsByName[eventName] = eventsForName = new List<Event>();

        // Make sure that every event has a unique names, Warn if this is not true and morph name by adding the EventId as a suffix.  
        foreach (var eventWithName in eventsForName)
        {
            if (eventWithName.Id != eventId)
            {
                var newName = eventName + eventId.ToString();
                Console.WriteLine("Error: events with ID {0} and {1} have the same name (same opcode name and task name) renaming to {2} fix.",
                    eventWithName.Id, eventId, newName);
                // TODO should we rename or simply leave it?   Not clear yet... For now we rename   
                return GetEventsForName(newName, eventId);
            }
        }
        return eventsForName;
    }

    /* Once you have created a TraceParserGen, you can set various options using the properties below */
    /// <summary>
    /// This is the prefix for any class names.  Users can override this, but by default
    /// it is the last component (components separated by -) of the provider name.  Users
    /// can override this however.  
    /// </summary>
    public string ClassNamePrefix
    {
        get
        {
            if (m_ClassNamePrefix == null)
            {
                m_ClassNamePrefix = TraceParserGen.ToCSharpName(m_provider.Name);
                // We use the last component of the - separated list.  
                int lastDash = m_ClassNamePrefix.LastIndexOf('-');
                if (lastDash > 0)
                    m_ClassNamePrefix = m_ClassNamePrefix.Substring(lastDash + 1);
            }
            return m_ClassNamePrefix;
        }
        set
        {
            m_ClassNamePrefix = value;
        }
    }
    /// <summary>
    /// If set then it assumes that the generated class should be internal and not public.   
    /// </summary>
    public bool Internal;
    /// <summary>
    /// If true it will cause the generation of a 'state' class associated with the parser to hold information needed from one event to the next 
    /// </summary>
    public bool NeedsParserState;

    /// <summary>
    /// Once you have set all the properties you wish, you can actually geneate a TraceEventParser to a 
    /// particular output file by calling this routine.  
    /// </summary>
    public void GenerateTraceEventParserFile(string outputFileName)
    {
        using (var output = File.CreateText(outputFileName))
        {
            output.WriteLine("using System;");
            output.WriteLine("using System.Diagnostics;");
            output.WriteLine("using System.Diagnostics.Tracing;");
            output.WriteLine("using System.Text;");
            output.WriteLine("using Microsoft.Diagnostics.Tracing;");
            output.WriteLine("using Address = System.UInt64;");
            output.WriteLine();
            output.WriteLine("#pragma warning disable 1591        // disable warnings on XML comments not being present");
            output.WriteLine("");
            output.WriteLine("// This code was automatically generated by the TraceParserGen tool, which converts");
            output.WriteLine("// an ETW event manifest into strongly typed C# classes.");
            GenerateTraceEventParserClass(output);
        }
    }

    #region private

    /* Methods that implement the main spine of the C# code generation */
    private void GenerateTraceEventParserClass(TextWriter output)
    {
        output.WriteLine("namespace Microsoft.Diagnostics.Tracing.Parsers");
        output.WriteLine("{");
        output.WriteLine("    using Microsoft.Diagnostics.Tracing.Parsers.{0};", ClassNamePrefix);
        output.WriteLine("");

        string stateClassName = ClassNamePrefix + "State";

        output.WriteLine("    [System.CodeDom.Compiler.GeneratedCode(\"traceparsergen\", \"2.0\")]");
        output.WriteLine("    public sealed class " + ClassNamePrefix + "TraceEventParser : TraceEventParser ");
        output.WriteLine("    {");
        output.WriteLine("        public static string ProviderName = \"" + m_provider.Name + "\";");
        output.WriteLine("        public static Guid ProviderGuid = " + CodeForGuidLiteral(m_provider.Id) + ";");
        GenerateKeywords(output);
        output.WriteLine("        public " + ClassNamePrefix + "TraceEventParser(TraceEventSource source) : base(source) {}");
        output.WriteLine("");

        // *********** GENERATE EVENTS ********** //
        GenerateEvents(output);
        output.WriteLine("");
        output.WriteLine("        #region private");
        output.WriteLine("        protected override string GetProviderName() { return ProviderName; }");
        output.WriteLine();

        // *********** GENERATE TEMPLATE DEFINTITIONS ********** //
        GenerateTemplateDefs(output);

        if (NeedsParserState)
        {
            output.WriteLine("        private " + stateClassName + " State");
            output.WriteLine("        {");
            output.WriteLine("            get");
            output.WriteLine("            {");
            output.WriteLine("                " + stateClassName + " ret = (" + stateClassName + ") StateObject;");
            output.WriteLine("                if (ret == null) ");
            output.WriteLine("                {");
            output.WriteLine("                    ret = new " + stateClassName + "();");
            output.WriteLine("                    ParserState = ret;");
            output.WriteLine("                }");
            output.WriteLine("                return ret;");
            output.WriteLine("            }");
            output.WriteLine("        }");
            output.WriteLine("        " + stateClassName + " state;");
        }
        output.WriteLine("        #endregion");
        output.WriteLine("    }");
        if (NeedsParserState)
        {
            output.WriteLine("    #region private types");
            output.WriteLine("    internal class " + stateClassName + " : IFastSerializable");
            output.WriteLine("    {");
            output.WriteLine("        //TODO: Fill in");
            output.WriteLine("        void IFastSerializable.ToStream(Serializer serializer)");
            output.WriteLine("        {");
            output.WriteLine("        }");
            output.WriteLine("        void IFastSerializable.FromStream(Deserializer deserializer)");
            output.WriteLine("        {");
            output.WriteLine("        }");
            output.WriteLine("    }");
            output.WriteLine("    #endregion");
        }
        output.WriteLine("}");
        output.WriteLine("");

        output.WriteLine("namespace Microsoft.Diagnostics.Tracing.Parsers.{0}", ClassNamePrefix);
        output.WriteLine("{");

        // *********** GENERATE CLASSES ********** //
        GenerateEventPayloadClass(output, stateClassName);

        GenerateEnumerations(output);

        output.WriteLine("}");
    }

    private void GenerateKeywords(TextWriter output)
    {
        output.WriteLine("        public enum Keywords : long");
        output.WriteLine("        {");
        ulong keyword = 1;
        for (int i = 0; i < 64; i++)
        {
            string name = TraceParserGen.ToCSharpName(m_provider.GetKeywordName(i));
            if (name != null)
            {
                name = FixKeywordName(name);
                output.WriteLine("            {0} = 0x{1:x},", name, keyword);
            }
            keyword = keyword << 1;
        }
        output.WriteLine("        };");
        output.WriteLine("");
    }

    /// <summary>
    /// Change convention from ETW_KEYWORD_SESSION" to Session
    /// </summary>
    private static string FixKeywordName(string keywordName)
    {
        int keywordIdx = keywordName.IndexOf("KEYWORD_");
        if (0 <= keywordIdx)
            keywordName = keywordName.Substring(keywordIdx + 8);

        // Convert it to CamelCase.  

        var sb = new StringBuilder();
        bool capitalizeNext = true;
        for (int i = 0; i < keywordName.Length; i++)
        {
            char c = keywordName[i];
            if (c == '_')
                capitalizeNext = true;
            else
            {
                if (capitalizeNext)
                    c = Char.ToUpperInvariant(c);
                else
                    c = Char.ToLowerInvariant(c);
                sb.Append(c);
                capitalizeNext = false;
            }
        }
        return sb.ToString();
    }

    /// <summary>
    /// Generate the *Template helper functions as well as the EnumerateTemplates operation.  
    /// </summary>
    /// <param name="output"></param>
    private void GenerateTemplateDefs(TextWriter output)
    {

        // Geneate all the helper functions that initialize a single template for an event.  
        foreach (var keyValue in m_eventsByName)
        {
            var evntName = keyValue.Key;
            var evnt = keyValue.Value[0];
            string templateClassName = GetTemplateNameForEvent(evnt, evntName);
            var stateArg = "";
            if (NeedsParserState)
                stateArg = ", " + templateClassName + "State state=null";
            output.WriteLine("        static private {0} {1}Template(Action<{0}> action{2})", templateClassName, TraceParserGen.ToCSharpName(evntName), stateArg);
            output.WriteLine("        {                  // action, eventid, taskid, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName");
            var state = "";
            if (NeedsParserState && templateClassName != "EmptyTraceData")
                state = ", state";
            output.WriteLine("            return new {0}(action, {1}, {2}, \"{3}\", Guid.Empty, {4}, \"{5}\", ProviderGuid, ProviderName {6});",
                templateClassName, evnt.Id, evnt.Task, TraceParserGen.ToCSharpName(evnt.TaskName), evnt.Opcode, TraceParserGen.ToCSharpName(evnt.OpcodeName), state);
            output.WriteLine("        }");
        }

        var internalOpt = "";
        if (Internal)
            internalOpt = "internal ";

        output.WriteLine();
        output.WriteLine("        static private volatile TraceEvent[] s_templates;");
        output.WriteLine("        protected {0}override void EnumerateTemplates(Func<string, string, EventFilterResponse> eventsToObserve, Action<TraceEvent> callback)", internalOpt);
        output.WriteLine("        {");
        output.WriteLine("            if (s_templates == null)");
        output.WriteLine("            {");
        output.WriteLine("                var templates = new TraceEvent[{0}];", m_provider.Events.Count);
        for (int i = 0; i < m_provider.Events.Count; i++)
            output.WriteLine("                templates[{0}] = {1}Template(null);", i, TraceParserGen.ToCSharpName(m_provider.Events[i].EventName));
        output.WriteLine("                s_templates = templates;"); 
        output.WriteLine("            }");
        output.WriteLine("            foreach (var template in s_templates)");
        output.WriteLine("                if (eventsToObserve == null || eventsToObserve(template.ProviderName, template.EventName) == EventFilterResponse.AcceptEvent)");
        output.WriteLine("                    callback(template);");
        output.WriteLine("        }");
        output.WriteLine();
    }

    /// <summary>
    /// Emit the C# events that allow you to get callback 
    /// </summary>
    private void GenerateEvents(TextWriter output)
    {
        foreach (var keyValue in m_eventsByName)
        {
            var evntName = keyValue.Key;
            Debug.Assert(0 < keyValue.Value.Count);
            var evnt = keyValue.Value[0];

            string templateClassName = GetTemplateNameForEvent(evnt, evntName);

            output.WriteLine("        public event Action<" + templateClassName + "> " + evntName);
            output.WriteLine("        {");
            output.WriteLine("            add");
            output.WriteLine("            {");
            var extraArg = "";
            if (NeedsParserState)
                extraArg = ", State";
            // Call the *Template() function that does the work
            output.WriteLine("                source.RegisterEventTemplate(" + TraceParserGen.ToCSharpName(evntName) + "Template(value" + extraArg + "));");
            output.WriteLine("            }");
            output.WriteLine("            remove");
            output.WriteLine("            {");
            output.WriteLine("                source.UnregisterEventTemplate(value, " + evnt.Id + ", ProviderGuid);");
            output.WriteLine("            }");
            output.WriteLine("        }");
        }
    }

    private void GenerateEventPayloadClass(TextWriter output, string stateClassName)
    {
        // Severla distinct events might have the same payload class, this Dictionary keeps track
        // of which we have emitted so we don't emit it twice.  
        var classesEmitted = new Dictionary<string, string>();

        // For every event of the same name  
        foreach (var keyValue in m_eventsByName)
        {
            var eventName = keyValue.Key;
            var versionsForEvent = keyValue.Value;

            // We have to accumulate all the information needed to fetch a field, across all the versions of the event
            // Only then can we emit the code that will work for all fields simultaneously.  
            var fieldVersions = new SortedDictionary<string, List<FieldInfo>>();
            // allFields is the accumluation of all the values in 'fieldsVersions'
            List<FieldInfo> allFields = new List<FieldInfo>();
            string lengthAssert = "";       // Ultimately it is a expression which is true about the payload length
            GetFieldInfoByField(versionsForEvent, fieldVersions, allFields, ref lengthAssert);

            if (allFields.Count <= 0)
                continue;

            // This is the name of the template we will be generating.   
            string templateClassName = GetTemplateNameForEvent(versionsForEvent[0], eventName);

            // Have we done it already?
            if (classesEmitted.ContainsKey(templateClassName))
                continue;
            classesEmitted.Add(templateClassName, null);

            // OK we are ready to write it all out.  
            output.WriteLine("    public sealed class " + templateClassName + " : TraceEvent");
            output.WriteLine("    {");

            // Write out all the getters.  
            foreach (FieldInfo fieldInfo in allFields)
            {
                string name = fieldInfo.Name;
                if (SkipPadOrReservedFields(fieldInfo))
                    output.WriteLine("        // Skipping " + fieldInfo.Name);
                else
                {
                    // Take cases on struct array, struct, value array, value.
                    if (fieldInfo.GetType() == typeof(StructInfo))
                    {
                        // Struct or struct array.  Iterate through all fields contained
                        // in the struct

                        // TODO: Multiple version support not available yet for struct fields
                        StructInfo structInfo = (StructInfo)fieldInfo;

                        foreach (FieldInfo structSubfieldInfo in structInfo.StructSubfieldInfos)
                        {
                            if (structInfo.VarSizedArrayCountPropertyName == null)
                            {
                                // struct (not array):
                                // The getter for each struct field looks just like a
                                // regular field getter, except the field name is
                                // prepended with the struct name
                                output.WriteLine("        public " + structSubfieldInfo.Type + " " + name + "_" + structSubfieldInfo.Name + "{ get { return " + structSubfieldInfo.Fetch() + "; } }");

                                // TODO: Arrays contained inside structs not supported
                            }
                            else
                            {
                                // var-sized array of an entire structure.  Create a
                                // method that takes an array index as parameter

                                // TODO: Fixed-sized arrays of structs not yet supported
                                // by traceparsergen
                                int dummy;
                                Debug.Assert(!int.TryParse(structInfo.VarSizedArrayCountPropertyName, out dummy));

                                output.WriteLine("        public " + structSubfieldInfo.Type + " " + name + "_" + structSubfieldInfo.Name + "(int arrayIndex) { return " + structSubfieldInfo.Fetch() + "; }");
                            }
                        }
                    }
                    else
                    {
                        // Not a struct field.  Just a regular field or array of fields

                        List<FieldInfo> versions = fieldVersions[name];

                        if (fieldInfo.VarSizedArrayCountPropertyName == null)
                        {
                            output.WriteLine("        public " + GetType(versions) + " " + name + " { get { " + GetPropertyStmt(versions, versionsForEvent.Count) + " } }");
                        }
                        else if (fieldInfo.Type == "byte[]")
                        {
                            // for 'byte[]' we generate two accessors: the first allocates a new byte[], the second allows indexed access
                            output.WriteLine("        public " + GetType(versions) + " " + name + " { get { " + GetPropertyStmt(versions, versionsForEvent.Count) + " } }");
                        }
                        else
                        {
                            // Var-sized non-blob arrays are accessed not via properties, but
                            // methods that take an array index as parameter. 
                            // (Note:  Perhaps this should be done for fixed-sized
                            // arrays as well?)
                            output.WriteLine("        public " + GetType(versions) + " " + name + "(int arrayIndex) { " + GetPropertyStmt(versions, versionsForEvent.Count) + " }");
                        }
                    }
                }
            }

            AddGetFormattedMessageMethodOverride(output, eventName);

            output.WriteLine("");
            output.WriteLine("        #region Private");

            // Write out the constructor
            output.Write("        internal " + templateClassName + "(Action<" + templateClassName + "> target, int eventID, int task, string taskName, Guid taskGuid, int opcode, string opcodeName, Guid providerGuid, string providerName");
            if (NeedsParserState)
                output.Write(", " + ClassNamePrefix + "State state");
            output.WriteLine(")");
            output.WriteLine("            : base(eventID, task, taskName, taskGuid, opcode, opcodeName, providerGuid, providerName)");
            output.WriteLine("        {");
            output.WriteLine("            this.m_target = target;");
            if (NeedsParserState)
                output.WriteLine("            this.m_state = state;");
            output.WriteLine("        }");

            var internalOpt = "";
            if (Internal)
                internalOpt = "internal ";

            // Write out the dispatch method
            output.WriteLine("        protected {0}override void Dispatch()", internalOpt);
            output.WriteLine("        {");
            output.WriteLine("            m_target(this);");
            output.WriteLine("        }");

            // And the debugging logic
            output.WriteLine("        protected {0}override void Validate()", internalOpt);
            output.WriteLine("        {");
            output.Write(lengthAssert);
            output.WriteLine("        }");

            // And for setting and inspecting the callback delegate
            output.WriteLine("        protected {0}override Delegate Target", internalOpt);
            output.WriteLine("        {");
            output.WriteLine("            get { return m_target; }");
            output.WriteLine("            set { m_target = (Action<" + templateClassName + ">) value; }");
            output.WriteLine("        }");

            // Write out a 'ToXml' that has all the fields
            output.WriteLine("        public override StringBuilder ToXml(StringBuilder sb)");
            output.WriteLine("        {");
            output.WriteLine("             Prefix(sb);");
            foreach (FieldInfo fieldInfo in allFields)
            {
                if (!SkipPadOrReservedFields(fieldInfo) && (fieldInfo.GetType() != typeof(StructInfo)) && (fieldInfo.VarSizedArrayCountPropertyName == null))
                {
                    string printFtn = "XmlAttrib";
                    if (fieldInfo.Type == "Address" || fieldInfo.HexFormat)
                        printFtn = "XmlAttribHex";
                    output.WriteLine("             " + printFtn + "(sb, \"" + fieldInfo.Name + "\", " + fieldInfo.Name + ");");
                }
            }
            output.WriteLine("             sb.Append(\"/>\");");
            output.WriteLine("             return sb;");
            output.WriteLine("        }");
            output.WriteLine("");

            // Write out the PayLoadNames method
            output.WriteLine("        public override string[] PayloadNames");
            output.WriteLine("        {");
            output.WriteLine("            get");
            output.WriteLine("            {");
            output.WriteLine("                if (payloadNames == null)");
            output.Write("                    payloadNames = new string[] { ");
            bool first = true;
            foreach (FieldInfo fieldInfo in allFields)
            {
                if (!SkipPadOrReservedFields(fieldInfo) && (fieldInfo.GetType() != typeof(StructInfo)))
                {
                    if (!first)
                        output.Write(", ");
                    output.Write("\"" + fieldInfo.Name + "\"");
                    first = false;
                }
            }
            output.WriteLine("};");
            output.WriteLine("                return payloadNames;");
            output.WriteLine("            }");
            output.WriteLine("        }");
            output.WriteLine("");

            // Write out the PayloadValue method
            output.WriteLine("        public override object PayloadValue(int index)");
            output.WriteLine("        {");
            output.WriteLine("            switch (index)");
            output.WriteLine("            {");
            int fieldNum = 0;
            foreach (FieldInfo fieldInfo in allFields)
            {
                if (!SkipPadOrReservedFields(fieldInfo) && (fieldInfo.GetType() != typeof(StructInfo)) && (fieldInfo.VarSizedArrayCountPropertyName == null))
                {
                    output.WriteLine("                case " + fieldNum + ":");
                    output.WriteLine("                    return " + fieldInfo.Name + ";");
                    fieldNum++;
                }
            }
            output.WriteLine("                default:");
            output.WriteLine("                    Debug.Assert(false, \"Bad field index\");");
            output.WriteLine("                    return null;");
            output.WriteLine("            }");
            output.WriteLine("        }");
            output.WriteLine("");

            // Write out the fields specific to this TraceEvent (that are not payload)
            output.WriteLine("        private event Action<" + templateClassName + "> m_target;");
            if (NeedsParserState) {
                output.WriteLine("        protected internal override void SetState(object newState) { m_state = ("+ ClassNamePrefix + "State)newState; }");
                output.WriteLine("        private " + ClassNamePrefix + "State m_state;");
            }
            output.WriteLine("        #endregion");
            output.WriteLine("    }");
        }

    }

    private void AddGetFormattedMessageMethodOverride(TextWriter output, string eventName)
    {
        Event @event = m_provider.Events.FirstOrDefault(e => e.EventName == eventName);
        if (@event == null || @event.Message == null)
        {
            return;
        }

        output.WriteLine("");
        output.WriteLine("        public override string GetFormattedMessage(IFormatProvider formatProvider)");
        output.WriteLine("        {");

        List<string> stringFormatArgs = new List<string>();

        string messageFormat = @event.Message;
        MatchCollection matches = new Regex(@"%(\d)").Matches(@event.Message);
        for (int count = matches.Count - 1; count >= 0; count--)
        {
            Match match = matches[count];
            string matchedEventArgumentIndex = match.Groups[1].Value;   // Note: group with index 0 is the entire match result
            int eventPayloadIndex = int.Parse(matchedEventArgumentIndex) - 1;   // Index in EventSource is 1-based, while index in TraceEventParser is 0-based!

            stringFormatArgs.Insert(0, "PayloadValue(" + eventPayloadIndex + ")");

            string matchReplacement = "{" + count + "}";
            messageFormat = messageFormat.Substring(0, match.Index) + matchReplacement + messageFormat.Substring(match.Index + match.Length);
        }

        string formatArgsString = stringFormatArgs.Any() ? ", " + string.Join(", ", stringFormatArgs) : string.Empty;
        string formatStatement = @"            return string.Format(formatProvider, """ + messageFormat + @"""" + formatArgsString + ");";
        output.WriteLine(formatStatement);
        output.WriteLine("        }");
    }

    /// <summary>
    /// Accumulate all the information needed to fetch a field by field name.  Also compute the assert that
    /// we will use to confirm the payload length is good.   
    /// </summary>
    private void GetFieldInfoByField(List<Event> versionsForEvent, SortedDictionary<string, List<FieldInfo>> fieldVersions, List<FieldInfo> allFields, ref string lengthAssert)
    {
        int curVersion = 0;
        foreach (Event eventVersion in versionsForEvent)
        {
            if (eventVersion.Fields != null)
            {
                // Figure out the field offsets for the fields for this version.  
                FieldInfo lastField = null;
                foreach (FieldInfo fieldInfo in GetInfoForFields(eventVersion.Fields))
                {
                    List<FieldInfo> versionsOfField;
                    if (!fieldVersions.TryGetValue(fieldInfo.Name, out versionsOfField))
                    {
                        versionsOfField = new List<FieldInfo>();
                        fieldVersions.Add(fieldInfo.Name, versionsOfField);
                        allFields.Add(fieldInfo);
                    }
                    versionsOfField.Add(fieldInfo);
                    fieldInfo.VersionNum = eventVersion.Version;
                    fieldInfo.EventId = eventVersion.Id;
                    lastField = fieldInfo;
                }
                if (lastField != null)
                {
                    lengthAssert += "            Debug.Assert(!(Version == " + eventVersion.Version + " && EventDataLength != " + FieldInfo.Skip(lastField) + "));\r\n";
                    if (curVersion == versionsForEvent.Count - 1)
                        lengthAssert += "            Debug.Assert(!(Version > " + eventVersion.Version + " && EventDataLength < " + FieldInfo.Skip(lastField) + "));\r\n";
                }
            }
            curVersion++;
        }
    }

    /// <summary>
    /// Generate all the enumeration types needed by the class defintions.  
    /// </summary>
    /// <param name="output"></param>
    private void GenerateEnumerations(TextWriter output)
    {
        // We also keep track of every enumerated type we use so we can emit those defintions too
        var enumerationsUsed = new SortedDictionary<string, Enumeration>();

        // For every event of the same name  
        foreach (List<Event> versionsForEvent in m_eventsByName.Values)
        {
            foreach (var eventVersion in versionsForEvent)
            {
                // see what enumerations we use.  
                if (eventVersion.Fields != null)
                    foreach (Field field in eventVersion.Fields)
                        if (field.Enumeration != null)
                            enumerationsUsed[TraceParserGen.ToCSharpName(field.Enumeration.Name)] = field.Enumeration;
            }
        }

        // Emit all the enumerations that were used in the payload defintions.  
        foreach (var enumeration in enumerationsUsed.Values)
            GenerateEventEnumeration(enumeration, output);
    }

    private void GenerateEventEnumeration(Enumeration enumeration, TextWriter output)
    {
        if (enumeration.IsBitField)
            output.WriteLine("    [Flags]");

        // remove the Map suffix (more like .NET conventions)
        string name = EnumerationName(enumeration);

        output.WriteLine("    public enum {0}", name);
        output.WriteLine("    {");

        foreach (var keyValue in enumeration.Values)
            output.WriteLine("        {0} = 0x{1:x},", keyValue.Value, keyValue.Key);
        output.WriteLine("    }");
    }

    private static string EnumerationName(Enumeration enumeration)
    {
        string name = TraceParserGen.ToCSharpName(enumeration.Name);
        if (name.EndsWith("Map"))
            name = name.Substring(0, name.Length - 3);
        if (name.EndsWith("_Value", StringComparison.OrdinalIgnoreCase))
            name = name.Substring(0, name.Length - 6);
        return name;
    }

    /* More support methods */
    /// <summary>
    /// returns C# code that will generate 'guid' in an efficient way (initializing by string is
    /// inefficient). 
    /// </summary>
    private static string CodeForGuidLiteral(Guid guid)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("new Guid(");
        byte[] bytes = guid.ToByteArray();
        // Silverlight does not have the unsigned versions for the GUID.  Uggh.  OK force to the signed version
        sb.Append("unchecked((int) 0x");
        sb.Append(bytes[3].ToString("x").PadLeft(2, '0'));
        sb.Append(bytes[2].ToString("x").PadLeft(2, '0'));
        sb.Append(bytes[1].ToString("x").PadLeft(2, '0'));
        sb.Append(bytes[0].ToString("x").PadLeft(2, '0'));
        sb.Append("), unchecked((short) 0x");
        sb.Append(bytes[5].ToString("x").PadLeft(2, '0'));
        sb.Append(bytes[4].ToString("x").PadLeft(2, '0'));
        sb.Append("), unchecked((short) 0x");
        sb.Append(bytes[7].ToString("x").PadLeft(2, '0'));
        sb.Append(bytes[6].ToString("x").PadLeft(2, '0'));
        sb.Append(")");
        for (int i = 8; i < 16; i++)
            sb.Append(", 0x" + bytes[i].ToString("x").PadLeft(2, '0'));
        sb.Append(")");
        return sb.ToString();
    }
    private static bool SkipPadOrReservedFields(FieldInfo fieldInfo)
    {
        if (fieldInfo.Name == null)
            return true;
        if (fieldInfo.Type == null)
            return true;
        if (fieldInfo.Name.StartsWith("Reserved", StringComparison.OrdinalIgnoreCase))
        {
            if (fieldInfo.Name.Length == 8 || Char.IsDigit(fieldInfo.Name[8]))
                return true;
        }
        if (fieldInfo.Name.StartsWith("Pad", StringComparison.OrdinalIgnoreCase))
        {
            if (fieldInfo.Name.Length == 3 || Char.IsDigit(fieldInfo.Name[3]))
                return true;
        }
        return false;
    }
    private static string GetTemplateNameForEvent(Event evnt, string eventName)
    {
        var ret = "EmptyTraceData";
        if (evnt.Fields != null)
        {
            ret = TraceParserGen.ToCSharpName(evnt.TemplateName);
            if (ret == null || ret.StartsWith("tid_"))
                ret = TraceParserGen.ToCSharpName(eventName) + "Args";
        }
        return ret;
    }
    /// <summary>
    /// Find all the information needed to create a payload decode class for a template (including offsets
    /// of the fields) and returns it as a list of 'FieldInfo' structures.  
    /// </summary>
    List<FieldInfo> GetInfoForFields(IList<Field> fields)
    {
        FieldInfo prevFieldInfo = null;
        List<FieldInfo> ret = new List<FieldInfo>();

        foreach (Field field in fields)
        {
            string varSizedArray = null;
            int count = 1;
            if (field.CountField != null)
            {
                if (!int.TryParse(field.CountField, out count))
                {
                    count = 1;
                    varSizedArray = field.CountField;
                }
            }

            FieldInfo fieldInfo;
            if (field.Struct != null)
                fieldInfo = new StructInfo(TraceParserGen.ToCSharpName(field.Name));
            else
                fieldInfo = new FieldInfo(TraceParserGen.ToCSharpName(field.Name), field.Type, prevFieldInfo, count, varSizedArray);

            fieldInfo.PrevField = prevFieldInfo;
            ret.Add(fieldInfo);
            fieldInfo.HexFormat = field.HexFormat;

            if (field.Struct != null)
            {
                StructInfo structInfo = (StructInfo)fieldInfo;

                // A <struct> field will have its own <data> child elements, so call
                // self recursively to generate FieldInfos for all of them.
                List<FieldInfo> structSubfieldInfos = GetInfoForFields(field.Struct.Fields);

                // Calculate size/offset info about the struct
                int cbStruct = 0;
                int cPointersInStruct = 0;
                foreach (FieldInfo structSubfieldInfo in structSubfieldInfos)
                {
                    cbStruct += structSubfieldInfo.ByteSize;
                    cPointersInStruct += structSubfieldInfo.NumPointersInSize;

                    // Point each field back up to its struct
                    structSubfieldInfo.ContainingStructInfo = structInfo;
                }

                fieldInfo.Type = "<Type unused for structs>";
                fieldInfo.FetchMethod = "<FetchMethod unused for structs>";
                fieldInfo.ByteSize = cbStruct;
                fieldInfo.NumPointersInSize = cPointersInStruct;

                // Point struct to its fields
                structInfo.StructSubfieldInfos = structSubfieldInfos;
                continue;
            }

            if (field.Enumeration != null)
            {
                fieldInfo.Type = EnumerationName(field.Enumeration);
                fieldInfo.IsEnum = true;
            }
            fieldInfo.ByteSize *= count;
            prevFieldInfo = fieldInfo;
        }
        return ret;
    }
    /// <summary>
    /// Returns a string representing the C# code that will fetch the property for any of the versions described by 'versions'.  
    /// 'totalVersions' is the maximum number of versions that the event (not just the property) has.  
    /// </summary>
    private string GetPropertyStmt(List<FieldInfo> versions, int totalVersions)
    {
        Debug.Assert(versions.Count > 0);

        // The expression for fetching the previous version of this field.  Null is fine as it
        // does not match any legit fetch expression string. 
        string prevFetch = null;

        // Represents a statement that will compute the value of all versions up to the i'th one
        string curStmt;
        // If this field exists in all versions or the first version is version 0 (which means there
        // can not be any previous versions, we start out with the smallest version fetch
        // Otherwise we start out with null value (not present value).  
        if (versions.Count == totalVersions || versions[0].VersionNum == 0)
        {
            prevFetch = versions[0].Fetch();
            curStmt = "return " + prevFetch + ";";
        }
        else
            curStmt = "return " + versions[0].NullValue() + ";";

        // Versions are in ordered from lowest number to highest.  
        foreach (FieldInfo version in versions)
        {
            string fetch = version.Fetch();
            if (fetch != prevFetch)
            {
                Debug.Assert(version.VersionNum != 0);
                curStmt = "if (Version >= " + version.VersionNum + ") return " + fetch + "; " + curStmt;
                prevFetch = fetch;
            }
        }
        return curStmt;
    }
    private string GetType(List<FieldInfo> versions)
    {
        string ret = null;
        foreach (FieldInfo version in versions)
        {
            if (ret == null)
                ret = version.Type;
            ret = MergeType(ret, version.Type, false);
        }
        return ret;
    }

    /// <summary>
    /// insures that the name is a valid CSharp Identifier.  
    /// </summary>
    public static string ToCSharpName(string input)
    {
        if (input == null)
            return null;
        for (int i = 0; i < input.Length; i++)
        {
            char c = input[i];
            if (!Char.IsLetter(c) && !Char.IsDigit(c) && c != '_')
                return Regex.Replace(input, @"[^\w\d_]", "");          //Simply remove them.    
        }
        return input;
    }

    private string MergeType(string type1, string type2, bool triedSwap)
    {
        if (type1 == type2)
            return type1;
        if (type1 == "long" && type2 == "int")
            return "long";
        if (type1 == "long" && type2 == "Address")
            return "long";
        if (type1 == "Address" && type2 == "int")
            return "Address";
        if (triedSwap == false)
            return MergeType(type2, type1, true);
        Console.WriteLine("Error: Incompatible types " + type1 + " and " + type2 + " look for BAD_MERGE_OF in output for more.");
        return "BAD_MERGE_OF_" + type1 + "_AND_" + type2;
    }

    /// <summary>
    /// Represents all the information needed to decode a specific version of a field of a event payload.
    /// </summary>
    class FieldInfo
    {
        protected FieldInfo() { }
        public FieldInfo(string name, string typeName, FieldInfo prevField, int count, string varSizedArray)
        {
            this.VarSizedArrayCountPropertyName = varSizedArray;
            this.PrevField = prevField;

            Name = name;
            switch (typeName)
            {
                case "win:Pointer":
                case "trace:SizeT":
                    this.Type = "Address";
                    this.FetchMethod = "GetAddressAt";
                    this.NumPointersInSize = 1;
                    this.ByteSize = 4;
                    break;
                // Booleans are DWORD sized. 
                case "win:Boolean":
                    this.Type = "bool";
                    this.FetchMethod = "GetInt32At";
                    this.ByteSize = 4;
                    break;
                case "win:UInt8":
                case "win:HexInt8":
                case "win:Int8":
                    this.Type = "int";
                    this.FetchMethod = "GetByteAt";
                    this.ByteSize = 1;
                    break;
                case "win:UInt16":
                case "win:HexInt16":
                case "win:Int16":
                case "trace:Port":
                    this.Type = "int";
                    this.FetchMethod = "GetInt16At";
                    this.ByteSize = 2;
                    break;
                // TODO do we want to support unsigned?
                case "win:UInt32":
                case "win:HexInt32":
                case "win:Int32":
                case "trace:IPAddr":
                case "trace:IPAddrV4":
                    this.Type = "int";
                    this.FetchMethod = "GetInt32At";
                    this.ByteSize = 4;
                    break;
                case "win:Double":
                    this.Type = "double";
                    this.FetchMethod = "GetDoubleAt";
                    this.ByteSize = 8;
                    break;
                case "win:Float":
                    this.Type = "float";
                    this.FetchMethod = "GetSingleAt";
                    this.ByteSize = 4;
                    break;
                case "trace:WmiTime":
                case "win:HexInt64":
                case "win:UInt64":
                case "win:Int64":
                    this.Type = "long";
                    this.FetchMethod = "GetInt64At";
                    this.ByteSize = 8;
                    break;
                case "trace:UnicodeChar":
                    this.Type = "string";
                    this.FetchMethod = "GetFixedUnicodeStringAt(" + count + ", ";

                    // TODO add a fixed size string parser routine.  
                    this.ByteSize = 2;
                    break;
                case "win:UnicodeString":
                    this.Type = "string";
                    this.FetchMethod = "GetUnicodeStringAt";
                    this.SkipMethod = "SkipUnicodeString(" + FieldInfo.Skip(prevField) + ")";
                    break;
                case "win:AnsiString":
                    this.Type = "string";
                    this.FetchMethod = "GetUTF8StringAt";
                    this.SkipMethod = "SkipUTF8String(" + FieldInfo.Skip(prevField) + ")";
                    break;
                case "trace:IPAddrV6":
                    // TODO deal with this. 
                    this.ByteSize = 16;
                    break;
                case "trace:WBEMSid":
                    this.SkipMethod = "SkipSID(" + FieldInfo.Skip(prevField) + ")";
                    break;
                case "win:GUID":
                case "trace:Guid":
                    this.Type = "Guid";
                    this.FetchMethod = "GetGuidAt";
                    this.ByteSize = 16;
                    break;
                case "win:FILETIME":
                    this.Type = "DateTime";
                    this.FetchMethod = "DateTime.FromFileTime(GetInt64At";
                    this.ByteSize = 8;
                    break;
                case "win:Binary":
                    this.Type = "byte[]";
                    this.FetchMethod = "GetByteArrayAt";
                    this.ByteSize = 1;
                    break;
                default:
                    Debug.Assert(false, "Unknown type " + typeName);
                    break;
            }
        }

        public string Name;
        public string Type;
        public bool HexFormat;
        public bool IsEnum;
        public string FetchMethod;

        // Size in bytes of this field. If this field is a statically sized array, ByteSize
        // is the entire size of the array. If this field is a variable sized array (whose
        // size is determined at run-time by using the value of another field in the ETW
        // event), then ByteSize remains the size of each entry of the array.
        public int ByteSize;

        public int NumPointersInSize;
        public FieldInfo PrevField;
        public string SkipMethod;           // If the field is variable sized, this method can skip it.  
        public int VersionNum;
        public int EventId;

        // If this field resides inside a struct, this points to that struct (else this is null)
        public StructInfo ContainingStructInfo;

        // Name of property that returns the count, if this is a variable sized array (else null)
        public string VarSizedArrayCountPropertyName;

        /// <summary>
        /// Returns string representing code that returns a 'default' value (a value to return when the value
        /// does not exist in the payload. This is 0 for numeric values and null for string values.
        /// </summary>
        /// <returns></returns>
        public string NullValue()
        {
            if (Type == "string")
                return "\"\"";
            if (IsEnum)
                return "(" + Type + ")0";
            return "0";
        }

        // Typically, this gives a string representation of the offset of this field
        // (in bytes, relative to beginning of the containing event).  However, if this
        // field exists within a struct, then this gives the offset of this field relative
        // to the beginning of that struct
        public string Offset()
        {
            if (PrevField == null)
                return "0";
            return FieldInfo.Skip(PrevField);
        }
        /// <summary>
        /// Returns a string representing the offset of whatever is directly after this field. 
        /// This method is static so that it can be called on a null field, which is convenient in several places.
        /// </summary>
        /// <returns></returns>
        public static string Skip(FieldInfo field)
        {
            string loc = "0";
            int numPointers = 0;
            int numBytes = 0;

            // Go through the previous fields, adding up their offsets. 
            FieldInfo ptr = field;
            while (ptr != null)
            {
                if (ptr.SkipMethod != null)
                {
                    loc = ptr.SkipMethod;
                    break;
                }
                if (ptr.VarSizedArrayCountPropertyName == null)
                {
                    numBytes += ptr.ByteSize;
                }
                else
                {
                    // Var-sized arrays are skipped by multiplying the value of the property
                    // that returns the array count by the number of bytes per array entry
                    loc += "+ (" + ptr.VarSizedArrayCountPropertyName + "*" + ptr.ByteSize.ToString() + ")";
                }

                numPointers += ptr.NumPointersInSize;
                ptr = ptr.PrevField;
            }
            if (loc == "0")
                loc = numBytes.ToString();
            else if (numBytes > 0)
                loc = loc + "+" + numBytes.ToString();

            if (numPointers != 0)
                return "HostOffset(" + loc + ", " + numPointers + ")";
            return loc;
        }

        // Depending on the kind of field we're talking about, the fetch string will look
        // quite different:
        // 
        // 1) Typical case (non-array, non-struct value):
        // 
        //     FetchMethod(<OffsetToThisFieldFromEventStart>)
        //     
        // 2) Var-sized array of non-struct value:
        // 
        //     FetchMethod(<OffsetToThisFieldFromEventStart> + (arrayIndex * <SizeOfThisFieldInBytes>))
        //     
        // 3) This field resides in a single, non-array struct
        // 
        //     FetchMethod(<OffsetToTheContainingStructFromEventStart> + <OffsetToThisFieldFromStructStart>)
        //     
        // 4) This field resides in a var-sized array of structs
        // 
        //     FetchMethod(<OffsetToTheContainingStructFromEventStart> + (arrayIndex * <SizeOfContainingStructInBytes>) + <OffsetToThisFieldFromStructStart>)
        //     
        public string Fetch()
        {
            string ret = FetchMethod + "(";
            if (ContainingStructInfo == null)
            {
                if (VarSizedArrayCountPropertyName == null)
                {
                    // Non-struct, non-varsized array
                    // 
                    // FetchMethod(<OffsetToThisFieldFromEventStart>)
                    ret += Offset() + ")";
                }
                else if (Type == "byte[]")
                {
                    ret += Offset() + ", " + VarSizedArrayCountPropertyName + ")";
                }
                else
                {
                    // For Var-sized arrays of single (non-struct) values, after we get the
                    // offset to the beginning of the array, add in the extra offset to get
                    // to the specified arrayIndex
                    // 
                    // FetchMethod(<OffsetToThisFieldFromEventStart> + (arrayIndex * <SizeOfThisFieldInBytes>))
                    // TODO: I don't think this works on x64 for arrays of pointers
                    ret += Offset() + " + (arrayIndex * HostOffset(" + ByteSize.ToString() + ", " + NumPointersInSize.ToString() + ")))";
                }
            }
            else
            {
                if (ContainingStructInfo.VarSizedArrayCountPropertyName == null)
                {
                    // Single Struct (non-array)
                    // 
                    // FetchMethod(<OffsetToTheContainingStructFromEventStart> + <OffsetToThisFieldFromStructStart>)
                    ret += ContainingStructInfo.Offset() + " + " + Offset() + ")";
                }
                else
                {
                    // For fields residing in var-sized arrays of structs, we start with the
                    // offset to the containing struct, then skip struct entries in the
                    // array, and then finally add in the offset to this field relative to
                    // the start of the struct
                    // 
                    // FetchMethod(<OffsetToTheContainingStructFromEventStart> + (arrayIndex * <SizeOfContainingStructInBytes>) + <OffsetToThisFieldFromStructStart>)
                    ret += ContainingStructInfo.Offset() + " + (arrayIndex * HostOffset(" + ContainingStructInfo.ByteSize.ToString() + ", " + ContainingStructInfo.NumPointersInSize.ToString() + ")) + " + Offset() + ")";
                }
            }

            if (FetchMethod.IndexOf('(') >= 0)
                ret += ")";
            if (Type == "bool")
                ret = ret + " != 0";
            if (IsEnum)
                ret = "(" + Type + ")" + ret;
            return ret;
        }
    }

    // A struct embedded inside an event is considered its own field within the overall
    // event. The struct knows its entire size and offset, and also has a list of
    // "subfields"--each of which representing a particular field within the struct.
    class StructInfo : FieldInfo
    {
        public StructInfo(string name) { Name = name; }
        // List of "subfields" (<data> elements in manifest) contained within this <struct>
        public List<FieldInfo> StructSubfieldInfos;
    }

    /* Fields */
    /// <summary>
    /// This is the last component (- separted) of the provider name.  It decides what your TraceParserGen is named 
    /// </summary>
    private string m_ClassNamePrefix;
    /// <summary>
    /// All the information from the manifest file. 
    /// </summary>
    private Provider m_provider;
    /// <summary>
    /// We group events together by version during the processing.  
    /// </summary>
    SortedDictionary<string, List<Event>> m_eventsByName;
    #endregion
}
